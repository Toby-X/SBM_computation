gen_dat <- sbm_gen_diagdom(100,3,0,0.1,1)
# Data generation function here
sbm_gen_diagdom <- function(N, K, beta, b, seed){
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A <- matrix(rbinom(N*N, 1, EA), N, N)
list(A = A, Z = Z, B = B)
}
gen_dat <- sbm_gen_diagdom(100,3,0,0.1,1)
gen_dat$Z
isSymmetric(gen_dat$A)
seed <- 1
N <- 2e3
N <- 100
K <- 3
beta <- 0
b <- 0.1
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A <- lower.tri(EA, diag = TRUE)
A
str(A)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
# Data generation function here
sbm_gen_diagdom <- function(N, K, beta, b, seed){
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A <- matrix(NA, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
list(A = A, Z = Z, B = B)
}
dat_gen <- sbm_gen_diagdom(N,K,beta,b,1)
dat_gen$A
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A <- matrix(NA, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
A
View(A)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A[lower.tri(A, diag = TRUE)] <- A_lower
View(A)
A <- matrix(0, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
View(A)
# Data generation function here
sbm_gen_diagdom <- function(N, K, beta, b, seed){
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A <- matrix(0, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
list(A = A, Z = Z, B = B)
}
dat_gen <- sbm_gen_diagdom(N,K,beta,b,1)
isSymmetric(dat_gen$A)
head(Z)
# Data generation function here
sbm_gen_diagdom <- function(N, K, beta, b, seed){
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
diag(B) <- 3*rho/2
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A <- matrix(0, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
list(A = A, Z = Z, B = B)
}
dat_gen <- sbm_gen_diagdom(N,K,beta,b,1)
diag(B)
B[diag(B)]
# Data generation function here
sbm_gen_diagdom <- function(N, K, beta, b, seed){
set.seed(seed)
rho <- N^(-b)
v <- runif(K, 0, 1)
alpha <- v^beta
alpha <- alpha/sum(alpha)
B <- matrix(rho/2, K, K)
## change the diagonal element of B to 3*rho/2
B <- B + diag(rho, K)
Z <- t(rmultinom(N, 1, alpha))
EA <- Z%*%B%*%t(Z)
A_lower <- rbinom(N*(N+1)/2, 1,EA[lower.tri(EA, diag = TRUE)])
A <- matrix(0, N, N)
A[lower.tri(A, diag = TRUE)] <- A_lower
A <- A + t(A)
A <- A - diag(diag(A))
list(A = A, Z = Z, B = B)
}
gen_dat <- sbm_gen_diagdom(N,K,beta,b,seed)
setwd(getwd())
getwd()
library(MLmetrics)
?Accuracy
?NMI
library(aricode)
?NMI
install.packages("here")
library(here)
here()
here()
log100
log(100)
log(500)-log(100)
?MAE
B_lower <- B[lower.tri(B, diag = TRUE)]
?MSE
?ARE
?ARI
a1 <- list()
a2 <- list(a=1,b=2)
rbind(a1,a2)
a3 <- list(a=1,b=2)
rbind(a1,a2,a3)
a1 <- rbind(a1,a2,a3)
a1
train_sc <- function(N, K, beta, b, seed){
# generate data
data <- sbm_gen_diagdom(N, K, beta, b, seed)
A <- data$A
Z <- data$Z
B <- data$B
# spectral clustering
tic()
res <- spectral_clustering(A, K)
time <- toc()
time <- time$toc - time$tic
Z_hat <- res$Z
B_hat <- res$B
# find the best permutation
idx <- find_best_idx(Z, Z_hat)
Z_hat <- Z_hat[, idx]
z_clust <- mat2vec(Z)
z_hat_clust <- mat2vec(Z_hat)
# calculate the metrics
Z_ARI <- ARI(z_clust, z_hat_clust)
Z_NMI <- NMI(z_clust, z_hat_clust)
Z_F1_Score_macro <- F1_Score_macro(z_clust, z_hat_clust)
Z_F1_Score_micro <- F1_Score_micro(z_clust, z_hat_clust)
Z_Accuracy <- Accuracy(z_clust, z_hat_clust)
B_lower <- B[lower.tri(B, diag = TRUE)]
B_hat_lower <- B_hat[lower.tri(B_hat, diag = TRUE)]
B_MAE <- MAE(B_lower, B_hat_lower)
B_MSE <- MSE(B_lower, B_hat_lower)
list(Z_ARI = Z_ARI, Z_NMI = Z_NMI, Z_F1_Score_macro = Z_F1_Score_macro,
Z_F1_Score_micro = Z_F1_Score_micro, Z_Accuracy = Z_Accuracy,
B_MAE = B_MAE, B_MSE = B_MSE, time = time,
N = N, K = K, beta = beta, b = b, seed = seed)
}
library(doSNOW)
library(tictoc)
# wd set as the directory above
source("./utils.r")
source("./methods/spectral_clustering.R")
source("./metrics.r")
train_sc <- function(N, K, beta, b, seed){
# generate data
data <- sbm_gen_diagdom(N, K, beta, b, seed)
A <- data$A
Z <- data$Z
B <- data$B
# spectral clustering
tic()
res <- spectral_clustering(A, K)
time <- toc()
time <- time$toc - time$tic
Z_hat <- res$Z
B_hat <- res$B
# find the best permutation
idx <- find_best_idx(Z, Z_hat)
Z_hat <- Z_hat[, idx]
z_clust <- mat2vec(Z)
z_hat_clust <- mat2vec(Z_hat)
# calculate the metrics
Z_ARI <- ARI(z_clust, z_hat_clust)
Z_NMI <- NMI(z_clust, z_hat_clust)
Z_F1_Score_macro <- F1_Score_macro(z_clust, z_hat_clust)
Z_F1_Score_micro <- F1_Score_micro(z_clust, z_hat_clust)
Z_Accuracy <- Accuracy(z_clust, z_hat_clust)
B_lower <- B[lower.tri(B, diag = TRUE)]
B_hat_lower <- B_hat[lower.tri(B_hat, diag = TRUE)]
B_MAE <- MAE(B_lower, B_hat_lower)
B_MSE <- MSE(B_lower, B_hat_lower)
list(Z_ARI = Z_ARI, Z_NMI = Z_NMI, Z_F1_Score_macro = Z_F1_Score_macro,
Z_F1_Score_micro = Z_F1_Score_micro, Z_Accuracy = Z_Accuracy,
B_MAE = B_MAE, B_MSE = B_MSE, time = time,
N = N, K = K, beta = beta, b = b, seed = seed)
}
res0 <- train_sc(250,3,0,0.5,1)
?F1_Score
?F1_Score_macro
train_sc <- function(N, K, beta, b, seed){
# generate data
data <- sbm_gen_diagdom(N, K, beta, b, seed)
A <- data$A
Z <- data$Z
B <- data$B
# spectral clustering
tic()
res <- spectral_clustering(A, K)
time <- toc()
time <- time$toc - time$tic
Z_hat <- res$Z
B_hat <- res$B
# find the best permutation
idx <- find_best_idx(Z, Z_hat)
Z_hat <- Z_hat[, idx]
z_clust <- mat2vec(Z)
z_hat_clust <- mat2vec(Z_hat)
# calculate the metrics
Z_ARI <- ARI(z_clust, z_hat_clust)
Z_NMI <- NMI(z_clust, z_hat_clust)
Z_F1_Score <- F1_Score(z_clust, z_hat_clust)
Z_Accuracy <- Accuracy(z_clust, z_hat_clust)
B_lower <- B[lower.tri(B, diag = TRUE)]
B_hat_lower <- B_hat[lower.tri(B_hat, diag = TRUE)]
B_MAE <- MAE(B_lower, B_hat_lower)
B_MSE <- MSE(B_lower, B_hat_lower)
list(Z_ARI = Z_ARI, Z_NMI = Z_NMI, Z_F1_Score = Z_F1_Score,
Z_Accuracy = Z_Accuracy, B_MAE = B_MAE, B_MSE = B_MSE, time = time,
N = N, K = K, beta = beta, b = b, seed = seed)
}
res0 <- train_sc(250,3,0,0.5,1)
res0
numCores <- 6L
cl <- makeCluster(numCores)
registerDoSNOW(cl)
m <- 10
sc <- foreach(i=1:m,.combine=rbind,
.packages = c("RSpectra","gtools","tictoc","clue",
"MLMetric","aricode")) %dopar% {
N_list <- c(250)
b_list <- c(0.1)
K_list <- c(5)
beta_list <- c(0)
res <- list()
for (N in N_list) {
for (b in b_list) {
for (K in K_list) {
for (beta in beta_list) {
res <- rbind(res, train_sc(N, K, beta, b, i))
}
}
}
}
res
}
sc <- foreach(i=1:m,.combine=rbind,
.packages = c("RSpectra","gtools","tictoc","clue",
"MLMetrics","aricode")) %dopar% {
N_list <- c(250)
b_list <- c(0.1)
K_list <- c(5)
beta_list <- c(0)
res <- list()
for (N in N_list) {
for (b in b_list) {
for (K in K_list) {
for (beta in beta_list) {
res <- rbind(res, train_sc(N, K, beta, b, i))
}
}
}
}
res
}
res0
sc
sc <- foreach(i=1:m,.combine=rbind,
.packages = c("RSpectra","gtools","tictoc","clue",
"MLMetrics","aricode")) %dopar% {
N_list <- c(250, )
b_list <- c(0.1)
K_list <- c(5)
beta_list <- c(0)
res <- list()
for (N in N_list) {
for (b in b_list) {
for (K in K_list) {
for (beta in beta_list) {
res <- rbind(res, train_sc(N, K, beta, b, i))
}
}
}
}
res
}
sc <- foreach(i=1:m,.combine=rbind,
.packages = c("RSpectra","gtools","tictoc","clue",
"MLmetrics","aricode")) %dopar% {
N_list <- c(250, )
b_list <- c(0.1)
K_list <- c(5)
beta_list <- c(0)
res <- list()
for (N in N_list) {
for (b in b_list) {
for (K in K_list) {
for (beta in beta_list) {
res <- rbind(res, train_sc(N, K, beta, b, i))
}
}
}
}
res
}
sc <- foreach(i=1:m,.combine=rbind,
.packages = c("RSpectra","gtools","tictoc","clue",
"MLmetrics","aricode")) %dopar% {
N_list <- c(250)
b_list <- c(0.1)
K_list <- c(5)
beta_list <- c(0)
res <- list()
for (N in N_list) {
for (b in b_list) {
for (K in K_list) {
for (beta in beta_list) {
res <- rbind(res, train_sc(N, K, beta, b, i))
}
}
}
}
res
}
head(sc)
?Accuracy
source("./metrics.r")
train_sc <- function(N, K, beta, b, seed){
# generate data
data <- sbm_gen_diagdom(N, K, beta, b, seed)
A <- data$A
Z <- data$Z
B <- data$B
# spectral clustering
tic()
res <- spectral_clustering(A, K)
time <- toc()
time <- time$toc - time$tic
Z_hat <- res$Z
B_hat <- res$B
# find the best permutation
idx <- find_best_idx(Z, Z_hat)
Z_hat <- Z_hat[, idx]
z_clust <- mat2vec(Z)
z_hat_clust <- mat2vec(Z_hat)
# calculate the metrics
Z_ARI <- ARI(z_clust, z_hat_clust)
Z_NMI <- NMI(z_clust, z_hat_clust)
Z_F1_Score <- F1_Score(z_clust, z_hat_clust)
Z_Accuracy <- ERROR(z_clust, z_hat_clust)
B_lower <- B[lower.tri(B, diag = TRUE)]
B_hat_lower <- B_hat[lower.tri(B_hat, diag = TRUE)]
B_MAE <- MAE(B_lower, B_hat_lower)
B_MSE <- MSE(B_lower, B_hat_lower)
list(Z_ARI = Z_ARI, Z_NMI = Z_NMI, Z_F1_Score = Z_F1_Score,
Z_Accuracy = Z_Accuracy, B_MAE = B_MAE, B_MSE = B_MSE, time = time,
N = N, K = K, beta = beta, b = b, seed = seed)
}
res0 <- train_sc(250,3,0,.1,5)
res0
isSymmetric(A)
# Example usage:
# Set the parameters for the algorithm
set.seed(53)
# # true model
B <- matrix(c(1, 0.8, 0.25, 0.8, 1, 0, 0.25, 0, 0), nrow = 3)
# generate data of Z, where the true community is 1112223333, z is 10*3 matrix
z <- c(rep(1, 30), rep(2, 30), rep(3, 40))
# sample an A based on B and z
A <- matrix(0, nrow = 100, ncol = 100)
for (i in 1:100) {
for (j in i:100) {
if (i != j) {
A[i, j] <- rbinom(1, 1, B[z[i], z[j]])
}
}
}
A <- A + t(A)
k <- 3                                      # Number of clusters
fit <- fit_sbm(A, k)
library(mlsbm)   # For SBM
fit <- fit_sbm(A, k)
fit$P
FIT$Z
fit$z
## Example
## A is the adjacency matrix
K
K <- 3
c(K,K)
## Example
## A is the adjacency matrix
## Est
sbm_fit <- estimateSimpleSBM(A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F, nbBlocksRange=c(K,K), fast=T))
library(sbm)
## Example
## A is the adjacency matrix
## Est
sbm_fit <- estimateSimpleSBM(A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F, nbBlocksRange=c(K,K), fast=T))
fit2 <- SimpleSBM_fit(A, model = "bernoulli",
directed = F)
fit2 <- SimpleSBM_fit$new(A, model = "bernoulli",
directed = F)
SimpleSBM_fit$optimize(estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=T))
coef(sbm_fit)
predict(sbm_fit)
str(predict(sbm_fit))
str(fitted(sbm_fit))
plot(sbm_fit)
MySimpleSBM <- A %>% estimateSimpleSBM(model = "bernoulli")
mySimpleSBM$nbBlocks
MySimpleSBM <- A %>% estimateSimpleSBM(model = "bernoulli")
mySimpleSBM$nbBlocks
MySimpleSBM$nbBlocks
MySimpleSBM$NbNodes
MySimpleSBM$nbNodes
coef(MySimpleSBM, 'block')
coef(MySimpleSBM, 'edge')
coef(MySimpleSBM, 'connectivity')
B
print(MySimpleSBM)
MySimpleSBM$blockProp
MySimpleSBM$memberships
MySimpleSBM$indmemberships
MySimpleSBM$indMemberships
# connectivity
sbm_fit$connectParam
## Est
sbm_fit <- estimateSimpleSBM(A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=F))
# Z matrix
sbm_fit$indMemberships
# B connectivity
sbm_fit$connectParam
gen.dat <- sbm_gen_diagdom(2e3,10,0,0.1,1)
# Z matrix
sbm_fit$indMemberships
# B connectivity
sbm_fit$connectParam
sbm_fit <- estimateSimpleSBM(gen.dat$A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=T))
K <- 3
sbm_fit <- estimateSimpleSBM(gen.dat$A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=T,
exploreFactor=c(K)))
K <- 3
sbm_fit <- estimateSimpleSBM(A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=T,
exploreFactor=c(K)))
sbm_fit <- estimateSimpleSBM(A, model = "bernoulli",
estimOptions = list(nbCores=1, plot=F,
nbBlocksRange=c(K,K), fast=T,
exploreMin=K,
exploreMax=K))
sbm_fit$nbBlocks
