# control <- rmvnorm(n, c(0, 0), Sigma0)
# df_2 <- data.frame(rbind(treatment, control))
# colnames(df_2) <- c("x1", "x2")
# df_2$z <- rep(c(1,0), each=n)
# df_2$z <- as.factor(df_2$z)
# ggplot(df_2) +
#   geom_histogram(aes(x=x1, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x1")
# ggplot(df_2) +
#   geom_histogram(aes(x=x2, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x2")
set.seed(20241116)
n <- 1000
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, x1)
dat1 <- data.frame(x1, x2)
x1 <- runif(n, 0, 1)
x2 <- runif(n, x1, 1)
dat2 <- data.frame(x1, x2)
dat <- rbind(dat1, dat2)
dat$z <- rep(c(1,0), each=n)
dat$z <- as.factor(dat$z)
ggplot(dat) +
geom_histogram(aes(x=x2, fill=z), alpha=0.5, position="identity") +
ggtitle("Marginal Density of x1")
# Sigma0 <- matrix(c(1,0,0,1), ncol=2, byrow=TRUE)
# Sigma1 <- matrix(c(1,0.8,0.8,1), ncol=2, byrow=TRUE)
# treatment <- rmvnorm(n, c(0, 0), Sigma1)
# control <- rmvnorm(n, c(0, 0), Sigma0)
# df_2 <- data.frame(rbind(treatment, control))
# colnames(df_2) <- c("x1", "x2")
# df_2$z <- rep(c(1,0), each=n)
# df_2$z <- as.factor(df_2$z)
# ggplot(df_2) +
#   geom_histogram(aes(x=x1, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x1")
# ggplot(df_2) +
#   geom_histogram(aes(x=x2, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x2")
set.seed(20241116)
n <- 1000
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, x1)
dat1 <- data.frame(x1, x2)
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, 1-x1)
dat2 <- data.frame(x1, x2)
dat <- rbind(dat1, dat2)
dat$z <- rep(c(1,0), each=n)
dat$z <- as.factor(dat$z)
ggplot(dat) +
geom_histogram(aes(x=x2, fill=z), alpha=0.5, position="identity") +
ggtitle("Marginal Density of x1")
# Sigma0 <- matrix(c(1,0,0,1), ncol=2, byrow=TRUE)
# Sigma1 <- matrix(c(1,0.8,0.8,1), ncol=2, byrow=TRUE)
# treatment <- rmvnorm(n, c(0, 0), Sigma1)
# control <- rmvnorm(n, c(0, 0), Sigma0)
# df_2 <- data.frame(rbind(treatment, control))
# colnames(df_2) <- c("x1", "x2")
# df_2$z <- rep(c(1,0), each=n)
# df_2$z <- as.factor(df_2$z)
# ggplot(df_2) +
#   geom_histogram(aes(x=x1, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x1")
# ggplot(df_2) +
#   geom_histogram(aes(x=x2, fill=z), alpha=0.5, position="identity") +
#   ggtitle("Marginal Density of x2")
ggplot(dat, aes(x=x1, y=x2, color=z)) + geom_point()
setwd("D:/Programmes/SBM_computation")
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
# for (i in 1:N){
#   Z[i, x[i]] <- 1
# }
# # how to eliminate the before loop?
index2vec <- function(i){
z <- rep(0, K)
z[x[i]] <- 1
z
}
Z <- sapply(1:N, index2vec)
Z
}
vec2mat(c(1,2,3))
vec2mat(c(2,1,3))
vec2mat(c(2,1,3,2,1))
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
# for (i in 1:N){
#   Z[i, x[i]] <- 1
# }
# # how to eliminate the before loop?
index2vec <- function(i){
z <- rep(0, K)
z[x[i]] <- 1
z
}
Z <- sapply(1:N, index2vec)
t(Z)
}
vec2mat(c(2,1,3,2,1))
library("rstan")
library("gtools")
nCores <- 6L
options(mc.cores = nCores)
rstan_options(auto_write = TRUE)
gen_data <- function(N, K, a, b, alpha){
# two symmetric matrix
A <- matrix(0, N, N)
B <- matrix(0, K, K)
pi <- rdirichlet(1, alpha)
Z <- t(rmultinom(N, 1, pi))
b_list <- rbeta(K*(K+1)/2, a, b)
# lower triangular of B is b_list
B[lower.tri(B, diag = T)] <- b_list
B <- B + t(B) - diag(diag(B))
A_star <- Z %*% B %*% t(Z)
A[lower.tri(A, diag = T)] <- rbinom(N*(N+1)/2, 1, A_star[lower.tri(A, diag = T)])
A <- A + t(A) - diag(diag(A))
A
}
N <- 100
K <- 3
a <- 1
b <- 1
alpha <- rep(1, K)
set.seed(123)
A <- gen_data(N, K, a, b, alpha)
head(A)
isSymmetric(A)
tmp_sc <- spectral_clustering(A, K)
library(gtools)
library(RSpectra)
library(e1071)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
index2vec <- function(i){
z <- rep(0, K)
z[x[i]] <- 1
z
}
Z <- sapply(1:N, index2vec)
t(Z)
}
# 0-1 matrix 2 index vector
mat2vec <- function(Z){
apply(Z, 1, which.max)
}
# SCORE function
.find_act <- function(s,P){
sn = s+sum(P<=s)
while (sn %in% P){
sn = sn+1
}
return(sn)
}
SCORE <- function(U){
K = ncol(U)
P = NA
## pseudo-pruning
if (any(U[,1]<=1e-7)){
P = which(U[,1]<=1e-7)
U0 = U[-P,]
Us = U0/U0[,1]
} else {
Us = U/U[,1]
}
IK = diag(rep(1,K))
S = c()
Y0 = Us
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = Y%*%(IK-u%*%t(u))
}
if (!any(is.na(P))){
S = sapply(S,.find_act,P)
}
return(S)
}
# L2 normalization
svm_cone <- function(U, beta=0, max.it=50, eps=1e-12, cond_tre=150){
# U is the top eigenvectors
# K is the dimension of the data point
# beta is a "stablize" parameter, delete points with less norm than beta quantile
K = ncol(U)
row_norm = apply(U, 1, norm, "2")
if (beta != 0){
qbeta = as.numeric(quantile(row_norm,beta))
del_idx = which(row_norm<qbeta)
U = U[-del_idx,]
row_norm = row_norm[-del_idx]
}
Us = U/row_norm
# This param is chosen by the code of Xueyu Mao et. al.
if (K > 10){
nu = 2*K/nrow(U)
} else {
nu = K/nrow(U)
}
# One Class SVM
one_svm = e1071::svm(rep(1, nrow(Us)) ~ Us, kernel="linear", type="one-classification",
nu = nu, scale = F)
w = t(one_svm$coefs) %*% one_svm$SV
b = one_svm$rho
SVs = one_svm$SV
SV_idx = one_svm$index[rowSums(abs(SVs))>0]
b_y = Us %*% t(w)
# eps0 and eps1 are actually tuning parameters
eps0 = 0
eps1 = .02
flag = T
iter = 0
while (flag & iter < max.it) {
pure_idx = which(b_y<=b*(1+eps0))
SV_idx.new = unique(c(SV_idx,pure_idx))
SVs.new = Us[SV_idx.new,]
## Use Vertex Hunting instead of K-means
IK = diag(rep(1,K))
pure_idx = c()
Y0 = SVs.new
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
pure_idx = c(pure_idx,which.max(l))
u = Y[pure_idx[k],]/norm(Y[pure_idx[k],],"2")
u = data.matrix(u)
Y = Y%*%(IK-u%*%t(u))
}
pure_idx = SV_idx.new[pure_idx]
vp = U[pure_idx,]
np = 1/apply(vp,1,norm,"2")
yp = np*vp
if (kappa(yp)>cond_tre){
flag = T
eps0 = eps0 + eps1
} else {
flag = F
}
iter <- iter + 1
}
return(pure_idx)
}
# Spectral Estimation Algorithms
spectral_clustering <- function(A, K){
svd_A <- RSpectra::svds(A, K)
kmeans_res <- kmeans(svd_A$u, K, iter.max = 100,
nstart = 10, algorithm = "Lloyd")
clust_vec <- kmeans_res$cluster
Z <- vec2mat(clust_vec)
# calculate the B matrix
B_half <- solve(t(Z) %*% Z, t(Z) %*% svd_A$u)
B <- t(B_half) %*% (svd_A$d * B_half)
list(Z = Z, B = B)
}
spectral_simplex_null <- function(A, K){
N <- nrow(A)
svd_A <- RSpectra::svds(A, K)
if (all(svd_A$u[,1]<=1e-14)){
svd_A$u = -svd_A$u
svd_A$v = -svd_A$v
}
U <- svd_A$u
IK <- diag(rep(1,K))
S <- c()
for (k in 1:K) {
l <- apply(U,1,norm,"2")
S <- c(S,which.max(l))
u <- U[S[k],]/norm(U[S[k],],"2")
u <- data.matrix(u)
U <- U%*%(IK-u%*%t(u))
}
Z_mixed <- svd_A$u%*%solve(svd_A$u[S,])
kmeans_res <- kmeans(Z_mixed, K, iter.max = 100,
nstart = 10, algorithm = "Lloyd")
clust_vec <- kmeans_res$cluster
Z <- vec2mat(clust_vec)
B_half <- solve(t(Z) %*% Z, t(Z) %*% svd_A$u)
B <- t(B_half) %*% (svd_A$d * B_half)
list(Z = Z, B = B)
}
spectral_simplex_score <- function(A, K){
svd_A <- RSpectra::svds(A, K)
if (all(svd_A$u[,1]<=1e-14)){
svd_A$u = -svd_A$u
svd_A$v = -svd_A$v
}
S <- SCORE(svd_A$u)
Z_mixed <- svd_A$u%*%solve(svd_A$u[S,])
kmeans_res <- kmeans(Z_mixed, K, iter.max = 100,
nstart = 10, algorithm = "Lloyd")
clust_vec <- kmeans_res$cluster
Z <- vec2mat(clust_vec)
B_half <- solve(t(Z) %*% Z, t(Z) %*% svd_A$u)
B <- t(B_half) %*% (svd_A$d * B_half)
list(Z = Z, B = B)
}
spectral_simplex_l2 <- function(A, K){
svd_A <- RSpectra::svds(A, K)
if (all(svd_A$u[,1]<=1e-14)){
svd_A$u = -svd_A$u
svd_A$v = -svd_A$v
}
S <- svm_cone(svd_A$u)
Z_mixed <- svd_A$u%*%solve(svd_A$u[S,])
kmeans_res <- kmeans(Z_mixed, K, iter.max = 100,
nstart = 10, algorithm = "Lloyd")
clust_vec <- kmeans_res$cluster
Z <- vec2mat(clust_vec)
B_half <- solve(t(Z) %*% Z, t(Z) %*% svd_A$u)
B <- t(B_half) %*% (svd_A$d * B_half)
list(Z = Z, B = B)
}
tmp_sc <- spectral_clustering(A, K)
svd_A <- RSpectra::svds(A, K)
kmeans_res <- kmeans(svd_A$u, K, iter.max = 100,
nstart = 10, algorithm = "Lloyd")
clust_vec <- kmeans_res$cluster
Z <- vec2mat(clust_vec)
Z
head(Z)
clust_vec
vec2mat(clust_vec)
index2vec <- function(i){
z <- rep(0, K)
z[x[i]] <- 1
z
}
sapply(1:N, index2vec)
x <- clust_vec
sapply(1:N, index2vec)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
index2vec <- function(i, x){
z <- rep(0, K)
z[x[i]] <- 1
z
}
Z <- sapply(1:N, index2vec, x)
t(Z)
}
tmp_sc <- spectral_clustering(A, K)
Z <- vec2mat(clust_vec)
head(Z)
model.matrix(~factor(clust_vec,levels=1:K)-1)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
Z[cbind(1:N, x)] <- 1
# for (i in 1:N) {
#   Z[i, x[i]] <- 1
# }
# index2vec <- function(i, x){
#   z <- rep(0, K)
#   z[x[i]] <- 1
#   z
# }
# Z <- sapply(1:N, index2vec, x)
# t(Z)
Z
}
vec2mat(clust_vec)
x
K <- which.max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
Z[cbind(1:N, x)] <- 1
cbind(1:N,x)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- which.max(x)
N <- length(x)
# Z <- matrix(0, nrow = N, ncol = K)
# Z[cbind(1:N, x)] <- 1
Z <- sparseMatrix(i = 1:N, j = x, x = 1,
dims = c(N, K))
# Z <- as.matrix(Z)
# for (i in 1:N) {
#   Z[i, x[i]] <- 1
# }
# index2vec <- function(i, x){
#   z <- rep(0, K)
#   z[x[i]] <- 1
#   z
# }
# Z <- sapply(1:N, index2vec, x)
# t(Z)
Z
}
vec2mat(x)
library(Matrix)
vec2mat(x)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
Z[cbind(1:N, x)] <- 1
# Z <- sparseMatrix(i = 1:N, j = x, x = 1,
#                   dims = c(N, K))
# Z <- as.matrix(Z)
# for (i in 1:N) {
#   Z[i, x[i]] <- 1
# }
# index2vec <- function(i, x){
#   z <- rep(0, K)
#   z[x[i]] <- 1
#   z
# }
# Z <- sapply(1:N, index2vec, x)
# t(Z)
Z
}
vec2mat(x)
# Index Vector 2 0-1 matrix
vec2mat <- function(x){
K <- max(x)
N <- length(x)
Z <- matrix(0, nrow = N, ncol = K)
Z[cbind(1:N, x)] <- 1
Z
}
tmp_sc <- spectral_clustering(A, K)
tmp_sc$Z
K
N <- 100
K <- 3
a <- 1
b <- 1
alpha <- rep(1, K)
set.seed(123)
A <- gen_data(N, K, a, b, alpha)
tmp_sc <- spectral_clustering(A, K)
head(tmp_sc$Z)
dat <- gen_data(N, K, a, b, alpha)
set.seed(123)
dat <- gen_data(N, K, a, b, alpha)
A <- dat$A
gen_data <- function(N, K, a, b, alpha){
# two symmetric matrix
A <- matrix(0, N, N)
B <- matrix(0, K, K)
pi <- rdirichlet(1, alpha)
Z <- t(rmultinom(N, 1, pi))
b_list <- rbeta(K*(K+1)/2, a, b)
# lower triangular of B is b_list
B[lower.tri(B, diag = T)] <- b_list
B <- B + t(B) - diag(diag(B))
A_star <- Z %*% B %*% t(Z)
A[lower.tri(A, diag = T)] <- rbinom(N*(N+1)/2, 1, A_star[lower.tri(A, diag = T)])
A <- A + t(A) - 2 * diag(diag(A))
list(A = A, Z = Z, B = B)
}
set.seed(123)
dat <- gen_data(N, K, a, b, alpha)
A <- dat$A
Z <- dat$Z
B <- dat$B
head(tmp_sc$Z)
head(dat$Z)
tmp_ss_null <- spectral_simplex_null(A, K)
head(tmp_ss_null$Z)
tmp_ss_SCORE <- spectral_simplex_score(A, K)
head(tmp_ss_SCORE$Z)
tmp_ss_l2 <- spectral_simplex_l2(A, K)
library(aricode)
true_clust <- mat2vec(dat$Z)
sc_clust <- mat2vec(tmp_sc$Z)
null_clust <- mat2vec(tmp_ss_null$Z)
SCORE_clust <- mat2vec(tmp_ss_SCORE$Z)
l2_clust <- mat2vec(tmp_ss_l2$Z)
ARI(true_clust, sc_clust)
ARI(true_clust, null_clust)
ARI(true_clust, SCORE_clust)
ARI(true_clust, l2_clust)
N <- 1000
set.seed(123)
dat <- gen_data(N, K, a, b, alpha)
A <- dat$A
Z <- dat$Z
B <- dat$B
tmp_sc <- spectral_clustering(A, K)
tmp_ss_null <- spectral_simplex_null(A, K)
tmp_ss_SCORE <- spectral_simplex_score(A, K)
tmp_ss_l2 <- spectral_simplex_l2(A, K)
true_clust <- mat2vec(dat$Z)
sc_clust <- mat2vec(tmp_sc$Z)
null_clust <- mat2vec(tmp_ss_null$Z)
SCORE_clust <- mat2vec(tmp_ss_SCORE$Z)
l2_clust <- mat2vec(tmp_ss_l2$Z)
ARI(true_clust, sc_clust)
ARI(true_clust, null_clust)
ARI(true_clust, SCORE_clust)
ARI(true_clust, l2_clust)
install.packages("sbm")
